<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>全面解析RNN,LSTM,Seq2Seq,Attention注意力机制 | CrazyJums</title><meta name="keywords" content="deep learning"><meta name="author" content="CrazyJums"><meta name="copyright" content="CrazyJums"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文将会使用大量的图片和公式推导通俗易懂地讲解RNN,LSTM,Seq2Seq和attention注意力机制（结合colah’s blog 和CS583），希望帮助初学者更好掌握且入门，若有已经掌握RNN，LSTM的读者自行跳过阅读即可,更详细的讲解在Seq2Seq,Attention那。  目录 RNN LSTM Seq2Seq 注意力机制 参考  1 RNN（递归神经网络）我们知道人类并不是">
<!-- hexo-inject:begin --><!-- hexo-inject:end --><meta property="og:type" content="article">
<meta property="og:title" content="全面解析RNN,LSTM,Seq2Seq,Attention注意力机制">
<meta property="og:url" content="http://jums.club/lstm-gru-rnn/index.html">
<meta property="og:site_name" content="CrazyJums">
<meta property="og:description" content="本文将会使用大量的图片和公式推导通俗易懂地讲解RNN,LSTM,Seq2Seq和attention注意力机制（结合colah’s blog 和CS583），希望帮助初学者更好掌握且入门，若有已经掌握RNN，LSTM的读者自行跳过阅读即可,更详细的讲解在Seq2Seq,Attention那。  目录 RNN LSTM Seq2Seq 注意力机制 参考  1 RNN（递归神经网络）我们知道人类并不是">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://jums.club/images/article/v2-6340abe431febf6304bafe9ca16edaba_1440w.jpg">
<meta property="article:published_time" content="2020-06-28T02:38:45.000Z">
<meta property="article:modified_time" content="2021-09-22T01:48:22.871Z">
<meta property="article:author" content="CrazyJums">
<meta property="article:tag" content="deep learning">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jums.club/images/article/v2-6340abe431febf6304bafe9ca16edaba_1440w.jpg"><link rel="shortcut icon" href="/images/favicon_64.ico"><link rel="canonical" href="http://jums.club/lstm-gru-rnn/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="yiOH4yHRf0eeVuko"/><meta name="qihu-site-verification" content="d182b3f28525f2db83acfaaf6e696dba"/><meta name="bing-site-verification" content="88688A1E5B9FE1F1F5EDAA94C73CD07D"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: '9335780214',
  enable_page_level_ads: 'true'
});</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?109416411ccef2c884dd6e0306467b1d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=UA-153513094-1"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-153513094-1');
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: CrazyJums","link":"Link: ","source":"Source: CrazyJums","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '全面解析RNN,LSTM,Seq2Seq,Attention注意力机制',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-09-22 09:48:22'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">230</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">63</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/leetcode/"><i class="fa-fw fa fa-code"></i><span> LeetCode</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-comments"></i><span> Comments</span></a></div><div class="menus_item"><a class="site-page" href="/kbooks/"><i class="fa-fw fa fa-book"></i><span> Kbooks</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/media/"><i class="fa-fw fa fa-play"></i><span> Media</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://jums.club/images/article/v2-6340abe431febf6304bafe9ca16edaba_1440w.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">CrazyJums</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/leetcode/"><i class="fa-fw fa fa-code"></i><span> LeetCode</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-comments"></i><span> Comments</span></a></div><div class="menus_item"><a class="site-page" href="/kbooks/"><i class="fa-fw fa fa-book"></i><span> Kbooks</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/media/"><i class="fa-fw fa fa-play"></i><span> Media</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">全面解析RNN,LSTM,Seq2Seq,Attention注意力机制<a class="post-edit-link" href="https://github.com/crazyjums/blog3/edit/master/source/_posts/lstm-gru-rnn.md" title="Edited on" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2020-06-28T02:38:45.000Z" title="Created 2020-06-28 10:38:45">2020-06-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-09-22T01:48:22.871Z" title="Updated 2021-09-22 09:48:22">2021-09-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">6.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>20min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="全面解析RNN,LSTM,Seq2Seq,Attention注意力机制"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">Comments:</span><a href="/lstm-gru-rnn/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/lstm-gru-rnn/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><p>本文将会使用大量的图片和公式推导通俗易懂地讲解RNN,LSTM,Seq2Seq和attention注意力机制（结合colah’s blog 和CS583），希望帮助初学者更好掌握且入门，若有已经掌握RNN，LSTM的读者自行跳过阅读即可,更详细的讲解在Seq2Seq,Attention那。</p>
</blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a><strong>目录</strong></h2><ul>
<li><strong>RNN</strong></li>
<li><strong>LSTM</strong></li>
<li><strong>Seq2Seq</strong></li>
<li><strong>注意力机制</strong></li>
<li><strong>参考</strong></li>
</ul>
<h2 id="1-RNN（递归神经网络）"><a href="#1-RNN（递归神经网络）" class="headerlink" title="1 RNN（递归神经网络）"></a><strong>1 RNN（递归神经网络）</strong></h2><p>我们知道人类并不是从零开始思考东西，就像你读这篇文章的时候，你对每个字的理解都是建立在前几个字上面。你读完每个字后并不是直接丢弃然后又从零开始读下一个字，因为你的思想是具有持续性的，很多东西你要通过上下文才能理解。</p>
<p>然而传统的神经网络并不能做到持续记忆理解这一点，这是传统神经网络的主要缺点。举个例子，你打算使用传统的神经网络去对电影里每个时间点发生的事情进行分类的时候，传统的神经网络先让不能使用前一个事件去推理下一个事件。</p>
<p>RNN（递归神经网络）可以解决这个问题。他们是带有循环的神经网络，允许信息在其中保留。</p>
<p><img src="https://pic4.zhimg.com/80/v2-f6d91e2e4b918295023bb490793057ef_720w.jpg" alt="img"></p>
<p>在上图中，A代表神经网络主体，<img src="https://www.zhihu.com/equation?tex=X_t" alt="[公式]">)表示网络的输入，<img src="https://www.zhihu.com/equation?tex=h_t" alt="[公式]">表示网络的输出。循环结构允许信息从当前输出传递到下一次（下个时间点）的网络输入。</p>
<p>这些循环让递归神经网络看起来有点神秘，然而如果你再思考一下，RNN其实和传统的神经网络并没有太多的不同。RNN可以看作是一个网络的多次拷贝，其中每次网络的输出都是下一次的输入。我们可以思考一下我们如果展开这个循环结构会是什么样的：</p>
<p><img src="https://pic4.zhimg.com/80/v2-b0326c567c7ea8ccea0f66a9bcbee133_720w.jpg" alt="img"></p>
<p>这种像是链状的网络结构表明RNN和序列以及列表有着天然的联系，他们是处理这些序列数据的天然的神经网络。而且很明显我们可以看出，输入输出的序列是具有相同的时间长度的，其中的每一个权值都是共享的（不要被链式形状误导，本质上只有一个cell）。</p>
<p>在最近的几年，RNN在很多问题上都取得了成功：比如语音识别，语音模型，翻译，图片注释等等，但是RNN存在着梯度消息/爆炸以及对长期信息不敏感的问题，所以LSTM就被提出来了。现在很多问题的成功都必须归功于LSTM，它是递归神经网络的一种，它在许多的任务中表现都比普通的RNN更好，所以接下来我们来探索一下这个神奇的网络。</p>
<h2 id="2-LSTM"><a href="#2-LSTM" class="headerlink" title="2 LSTM"></a><strong>2 LSTM</strong></h2><h3 id="2-1-长期依赖问题"><a href="#2-1-长期依赖问题" class="headerlink" title="2.1 长期依赖问题"></a><strong>2.1 长期依赖问题</strong></h3><p>人们希望RNN可以将一些之前的信息连接到当前的任务中来，比如使用之前的视频帧来帮助理解当前帧。如果RNN可以做到将会非常有用。那实际RNN能做到吗？这要视情况而定。</p>
<p>有时候，我们只需要当前的信息来完成当前的任务。举个例子，一个语音模型试图基于之前的单词去预测下一个单词。如果我们尝试预测“the clouds are in the sky”，我们不需要太多的上下文信息——很明显最后一个单词会是sky。在像这样不需要太多的相关信息的场合下，RNN可以学习到之前使用的信息。</p>
<p><img src="https://pic2.zhimg.com/80/v2-e943f02c5db894b9d5003673fde883fd_720w.jpg" alt="img"></p>
<p>但是我们要注意，也有很多场景需要使用更多的上下文。当我们试图去预测“I grew up in France… I speak fluent French”这句话的最后一个单词，最近的信息会表明这应该是一种语言的名字，但是如果我们需要知道具体是哪一种语语言，我们需要France这个在句子中比较靠前的上下文信息，相关信息和需要预测的点的间隔很大的情况是经常发生的。</p>
<p>不幸的是，随着间隔变大，RNN变得无法连接到太前的信息。</p>
<p><img src="https://pic3.zhimg.com/80/v2-b8207cc9e994f629c1fdafa1463cd27e_720w.jpg" alt="img"></p>
<p>理论上RNN完全可以处理这种长期依赖（long-term dependencies）的问题。人们可以通过小心地选择参数来解决这个问题。令人悲伤的是，实践表明RNN并不能很好地解决这个问题，Hochreiter (1991) [German] and Bengio, et al. (1994)发现了RNN为什么在这些问题上学习很困难的原因。</p>
<p>而LSTM则没有这个问题。</p>
<h3 id="2-2-LSTM网络"><a href="#2-2-LSTM网络" class="headerlink" title="2.2 LSTM网络"></a><strong>2.2 LSTM网络</strong></h3><p>长期短期记忆网络-通常叫做LSTM-是一种特殊结构的RNN，它能够学习长期依赖。它在大量的问题有惊人的效果，现在已经被广泛使用。</p>
<p>LSTM被明确设计来避免长期依赖问题，记住长时间的信息对LSTM来说只是常规操作，不像RNN那样费力不讨好。</p>
<p>所有的RNN都有不断重复网络本身的链式形式。在标准的RNN中，这个重复复制的模块只有一个非常简单的结果。例如一个tanh层：</p>
<p><img src="https://pic3.zhimg.com/80/v2-113963429a1e8a55da3a2b5f567619de_720w.jpg" alt="img"></p>
<p>LSTM也有这样的链式结构，但是这个重复的模块和上面RNN重复的模块结构不同：LSTM并不是只是增加一个简单的神经网络层，而是四个，他们以一种特殊的形式进行交互：</p>
<p><img src="https://pic2.zhimg.com/80/v2-f22c8c19679af32a976c0a1d012e3361_720w.jpg" alt="img"></p>
<p>读者不需要担心看不懂，接下来我们将会一步步理解这个LSTM图。首先我们先了解一下图中的符号：</p>
<p><img src="https://pic2.zhimg.com/80/v2-e62577dc9d77f353c14940f244f38c41_720w.jpg" alt="img"></p>
<p>在上图中，每条线表示一个向量，从一个输出节点到其他节点的输入节点。粉红色的圆圈表示逐点式操作，就像向量加法。黄色的盒子是学习好的神经网络层。线条合代表联结，线条分叉则表示内容被复制到不同的地方。</p>
<h3 id="2-3-LSTM背后的核心思想"><a href="#2-3-LSTM背后的核心思想" class="headerlink" title="2.3 LSTM背后的核心思想"></a><strong>2.3 LSTM背后的核心思想</strong></h3><p>LSTM的核心之处就是它的cell state(神经元状态)，在下图中就是那条贯穿整个结果的水平线。这个cell state就像是一个传送带，他只有很小的线性作用，但却贯穿了整个链式结果。信息很容易就在这个传送带上流动但是状态却不会改变。cell state上的状态相当于长期记忆，而下面的<img src="https://www.zhihu.com/equation?tex=h_t" alt="[公式]">则代表短期记忆。</p>
<p><img src="https://pic2.zhimg.com/80/v2-2b145c5aee8def6d7522081767d59191_720w.jpg" alt="img"></p>
<p>LSTM有能力删除或者增加cell state中的信息，这一个机制是由被称为门限的结构精心设计的。</p>
<p>门限是一种让信息选择性通过的方式，它们是由sigmoid神经网络层和逐点相乘器做成的。</p>
<p><img src="https://pic3.zhimg.com/80/v2-d160b6fdd11dba4d15675d55348c3d66_720w.png" alt="img"></p>
<p>sigmoid层输出0和1之间的数字来描述一个神经元有多少信息应该被通过。输出0表示这些信息全部不能通过，而输出1则表示让所有信息都通过。</p>
<p>一个LSTM有三个这样的门限，去保护和控制神经元的状态。</p>
<h3 id="2-4-一步步推导LSTM"><a href="#2-4-一步步推导LSTM" class="headerlink" title="2.4 一步步推导LSTM"></a><strong>2.4 一步步推导LSTM</strong></h3><p>LSTM的第一步就是决定什么信息应该被神经元遗忘。这是一个被称为“遗忘门层”的sigmod层组成。他输入<img src="https://www.zhihu.com/equation?tex=h_%7Bt-1%7D" alt="[公式]">)和<img src="https://www.zhihu.com/equation?tex=X_t" alt="[公式]">)（上一次的输出以及这轮的输入），然后在<img src="https://www.zhihu.com/equation?tex=C_%7Bt-1%7D" alt="[公式]">的每个神经元状态输出0和1之间的数字。同理1表示完全保留这些信息，0表示完全遗忘这个信息。</p>
<p>让我们再次回到一开始举的例子：根据之前的词语去预测下一个单词的语言模型。在这个问题中，cell state或许包括当前主语中的性别信息，所以我们可以使用正确的代词。而当我们看到一个新的主语（输入），我们会去遗忘之前的性别信息。我们使用下图中的公式计算我们的“遗忘系数”<img src="https://www.zhihu.com/equation?tex=f_t" alt="[公式]"></p>
<p><img src="https://pic4.zhimg.com/80/v2-5d4abda673fb23a704284d995543b397_720w.jpg" alt="img"></p>
<p>下一步就是决定我们要在cell state中保留什么信息。这包括两个部分。首先，一个被称为“输入门层”的sigmoid层会决定我们要更新的数值。然后一个tanh层生成一个新的候选数值<img src="https://www.zhihu.com/equation?tex=C_t%5E%EF%BD%9E" alt="[公式]">，它会被增加到cell state中。在下一步中，我们将会组合这两步去生成一个新的更新状态值。</p>
<p>在那个语言模型例子中，我们想给cell state增加主语的性别，来替换我们将要遗忘的旧的主语。</p>
<p><img src="https://pic3.zhimg.com/80/v2-6f3cad9392530f19ca22f78efea9de92_720w.jpg" alt="img"></p>
<p>现在是时候去更新旧的神经元状态<img src="https://www.zhihu.com/equation?tex=C_%7Bt-1%7D" alt="[公式]">)到新的神经元状态<img src="https://www.zhihu.com/equation?tex=C_t" alt="[公式]">。之前我们已经决定了要做什么，下一步我们就去做。</p>
<p>我们给旧的状态乘一个遗忘系数<img src="https://www.zhihu.com/equation?tex=f_t" alt="[公式]">)，来遗忘掉我们之前决定要遗忘的信息，然后我们增加<img src="https://www.zhihu.com/equation?tex=i_t+%2A+C_t" alt="[公式]">。这是新的候选值，由我们想多大程度更新每个状态的值决定。</p>
<p>在语言模型中，就像上面描述的，这是我们实际上要丢弃之前主语的性别信息，增加新的主语的性别信息的地方。</p>
<p><img src="https://pic2.zhimg.com/80/v2-f8f689f92b88d144ab9d8f47d3364dad_720w.jpg" alt="img"></p>
<p>最后，我们需要决定我们要输出什么。这个输出是建立在我们的cell state的基础上，但是这里会有一个滤波器。首先，我们使用sigmoid层决定哪一部分的神经元状态需要被输出；然后我们让cell state经过tanh(让输出值变成-1到1之间)层并且乘上sigmod门限的输出，这样我们就只输出我们想要输出的。</p>
<p>对于那个语言模型的例子，当我们看到一个新的主语的时候，或许我们想输出相关动词的信息，因为动词是跟在主语后面的。例如，它或许要输出主语是单数还是复数的，然后我们就知道主语后动词的语态了。</p>
<h3 id="2-5-LSTM的一些变体"><a href="#2-5-LSTM的一些变体" class="headerlink" title="2.5 LSTM的一些变体"></a><strong>2.5 LSTM的一些变体</strong></h3><p>上面讲的都是一些常规的LSTM，但并不是所有的LSTM都是上面这种形式。实际上现在很多包含LSTM的论文都有小的差异，但是它值得一提。</p>
<p><strong><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/135970560/[ftp://ftp.idsia.ch/pub/juergen/TimeCount-IJCNN2000.pdf](ftp://ftp.idsia.ch/pub/juergen/TimeCount-IJCNN2000.pdf)">Gers &amp; Schmidhuber (2000)</a></strong>引入了一个流行的LSTM变体，它增加了一个窥视孔连接。这意味着我们让门限层监视cell state的状态。</p>
<p><img src="https://pic4.zhimg.com/80/v2-e3e0ab13b034d6f52b693b99f7532673_720w.jpg" alt="img"></p>
<p>上图中给每一个门限都增加了窥视孔，但是有些论文只是给一部分的门限增加窥视孔，并不是全部都加上。</p>
<p>另外一个变体是使用组合遗忘和输入门，而不是分开决定哪些神经元需要遗忘信息，哪些需要增加新的信息，我们组合起来决定。我们只遗忘那些需要被放入新信息的状态，同样我们旨在旧信息被遗忘之后才输入新的信息。</p>
<p><img src="https://pic1.zhimg.com/80/v2-8e39e0e291ff9802a872e7771a2b7fa4_720w.jpg" alt="img"></p>
<p>一个更神奇的LSTM变体是门递归单元（也就是大家常说的GRU），它组合遗忘门和输入门为一个更新门，它合并了cell state和隐层状态，并且做了一些其他的改变。最终这个模型比标准的LSTM更简单，并且变得越来越流行。</p>
<p><img src="https://pic2.zhimg.com/80/v2-c310b7d10cb11b3cdf5860cea677e299_720w.jpg" alt="img"></p>
<p>这里只介绍了几个最有名的LSTM的变体，还有更多变体没有介绍，就像Yao, et al.(2015)深度门递归神经网络(Depth Gated RNNs)。这里也有一些处理长期依赖问题问题的完全不同的方法，就像Koutnik, et al(2014)提出的时钟机递归神经网络（Clockwork RNNs）。</p>
<h3 id="2-6-结论"><a href="#2-6-结论" class="headerlink" title="2.6 结论"></a><strong>2.6 结论</strong></h3><p>我们一开始提到人们使用RNN取得了卓越的成果，但其实本质上都是使用LSTM取得的，他们的确在多数任务上表现得更好。</p>
<p>写下来一系列等式以后，LSTM看起来挺吓人，但在文中一步步解释后它变得可以理解了。我们不禁想问：是否有比LSTM更好的模型？学者一致认为：那就是attention注意力机制。核心观点就是让RNN每一步都监视一个更大的信息集合并从中挑选信息。例如：如果你使用RNN去为一个图像生成注释，它会从图像中挑选一部分去预测输出的单词。接下来在讲解attention之前，我们会先聊聊Seq2Seq。</p>
<h2 id="3-Seq2Seq"><a href="#3-Seq2Seq" class="headerlink" title="3 Seq2Seq"></a><strong>3 Seq2Seq</strong></h2><p>我将会结合一个机器翻译的例子来给大家形象地介绍Seq2Seq。</p>
<p><img src="https://pic1.zhimg.com/80/v2-e16b362762cedcfd7da43cc8453dc158_720w.jpg" alt="img"></p>
<p>在这个例子中，我们试图将英语转换为德语，这里要注意这里是一个多对多的模型，而且输入和输出的长度都不固定。</p>
<h3 id="3-1-准备数据"><a href="#3-1-准备数据" class="headerlink" title="3.1 准备数据"></a><strong>3.1 准备数据</strong></h3><p><img src="https://pic1.zhimg.com/80/v2-f2054949f0b8b253907df10d4ab82fb0_720w.jpg" alt="img"></p>
<p>因为只是做一个例子，所以我们在<a href="https://link.zhihu.com/?target=http%3A//www.manythings.org/anki/">http://www.manythings.org/anki/</a>这个网站选一个小规模的数据来训练一个简单的Seq2Seq即可，我们可以看到左边是英语句子，右边则是翻译的德语句子。</p>
<p><img src="https://pic1.zhimg.com/80/v2-f6ce5b60a450e4cf4a19a640c6022efc_720w.jpg" alt="img"></p>
<p>我们先进行一下预处理，比如把大写字母变成小写，把标点符号去掉等等。</p>
<p><img src="https://pic2.zhimg.com/80/v2-a7e3592a72ba04e85cf99ed17ffd5645_720w.jpg" alt="img"></p>
<p>预处理完之后我们要做tokenization，即把一句话分成很多个单词或者字符，这里要注意做tokenization的时候要用两个tokenization，英语用一个，德语用一个；tokenization之后要建立两个字典，一个英语字典，一个德语字典，后面会解释我为什么要这么做。</p>
<p><img src="https://pic4.zhimg.com/80/v2-7c8e857a458ba06a87db6953c6a0f697_720w.jpg" alt="img"></p>
<p>tokenization可以是char-level，也可以是word-level，顾名思义前者就是会把一句话分为一个个字符，而后者则会把一句话分成一个个单词，为了简单方便，我们使用char-level来说明。</p>
<p><img src="https://pic1.zhimg.com/80/v2-0ead3b1abd0ba397554f4b9f872312f4_720w.jpg" alt="img"></p>
<p>经过tokenization之后一句话变成了一个list，每个元素都是一个字符，但实际中一般都使用word-level，因为他们的数据集足够大，这在之后会解释。</p>
<p><img src="https://pic4.zhimg.com/80/v2-894740bcc20244a4ebc930c5f3f5fc3f_720w.jpg" alt="img"></p>
<p>我们前面说了tokenization要用两个不同的字典，这是因为不同的语言它的字母表不同，无法进行统一的映射，如上图所示。</p>
<p><img src="https://pic4.zhimg.com/80/v2-cecb10d70bb98fe0cce4ef0d7f0e54cf_720w.jpg" alt="img"></p>
<p>如果你使用word-level，那就更有必要使用两个不同的字典，比如很多德语单词在英语字典中是找不到的，而且不同语言分词方便也是不一样的。</p>
<p><img src="https://pic1.zhimg.com/80/v2-f3cbee2f32494e4ced4d1e02e83b669c_720w.jpg" alt="img"></p>
<p>左边是英语字典，包括26个字母和一个空格符，德语字典删去了一些不常用字母后再加入空格符，另外可以发现德语字典多了一个起始符和一个终止符，这里用什么都行，只要别跟字典字符冲突就可以，后面大家就知道这两个符号的作用。</p>
<p><img src="https://pic1.zhimg.com/80/v2-31490bde1eb57e2264879d43200832b4_720w.jpg" alt="img"></p>
<p>tokenization结束之后每句话就变成了一个字符字典，然后原字符经过字典映射后就变成了下面这个序列，对于德语也是一样。</p>
<p><img src="https://pic2.zhimg.com/80/v2-72d1547efd4b5f44801a0cc6fd42fe79_720w.jpg" alt="img"></p>
<p>接下来我们还可以把这些数字变成One-hot向量表示，黑色表示1，白色表示0。经过One-hot每个字符就变成了一个向量，每句话就变成了一个矩阵，这就是我们的输入，现在数组准备好了，我们来搭建我们的Seq2Seq模型。</p>
<h3 id="3-2-搭建并训练Seq2Seq模型"><a href="#3-2-搭建并训练Seq2Seq模型" class="headerlink" title="3.2 搭建并训练Seq2Seq模型"></a><strong>3.2 搭建并训练Seq2Seq模型</strong></h3><p>Seq2Seq有一个编码器和一个解码器，编码器一般是LSTM或者其他模型用于提取特征，它的最后一个输出就是从这句话得出的最后的特征，而其他的隐层输出都被丢弃。</p>
<p><img src="https://pic1.zhimg.com/80/v2-fa481324e8de44a7cbaba0bf4f829820_720w.jpg" alt="img"></p>
<p>编码器提取特征之后就到了解码器，解码器靠编码器最后输出的特征也就是<img src="https://www.zhihu.com/equation?tex=%28h%2Cc%29" alt="[公式]">来知道这句话是”go away”，这里要强调一下Decoder的初始状态就是Encoder的最后一个状态，现在Decoder开始输出德语字母，这里Decoder也是一个LSTM模型，他每次接受一个输入然后输出下一个字母的概率，第一个输入必须是起始符，这就是我们为什么要在德语字典中要加入起始符的原因。Decoder会输出一个概率分布p向量，起始符后面的第一个字母是m，我们将m做一个one-hot编码作为y标签，用标签y和预测p做一个CrossEntropy来作为我们的损失函数优化，梯度从Decoder传回Encoder。</p>
<p><img src="https://pic2.zhimg.com/80/v2-456ac28a08fd696ae5b16d853ce8fe0d_720w.jpg" alt="img"></p>
<p>然后输入是两个字符，起始符和m，下一个字母是a，我们将a做one-hot编码作为y标签，将它与我们输出的概率分布做一个CrossEntropy来作为损失函数，一直进行这个循环，应该就很好理解了。</p>
<p><img src="https://pic1.zhimg.com/80/v2-0285b36667a84460d05485d92b22ca88_720w.jpg" alt="img"></p>
<p>最后一轮将整句德语作为输入，将停止符做标签y，再进行CrossEntropy，拿所有的英语和德语来训练我们的编码器和解码器，这就是我们的训练过程了。</p>
<p><img src="https://pic1.zhimg.com/80/v2-2ae2904095d5a5b53fb2c3b418282058_720w.jpg" alt="img"></p>
<p>总结一下，我们使用英语句子的one-hot矩阵作为encoder的输入，encoder网络由LSTM组成来提取特征，它的输出是最后一个状态<img src="https://www.zhihu.com/equation?tex=h" alt="[公式]">)和传送带<img src="https://www.zhihu.com/equation?tex=c" alt="[公式]">)，decoder网络的初始状态是<img src="https://www.zhihu.com/equation?tex=%28h%2Cc%29" alt="[公式]">)，decoder网络的输入是德语句子，decoder输出当前状态<img src="https://www.zhihu.com/equation?tex=h%5E%60" alt="[公式]">`,然后全连接层输出下一个字符的预测，这样我们的训练阶段就结束了。</p>
<p><img src="https://pic4.zhimg.com/80/v2-1944794b64645d28a95d2cb2e85be95f_720w.jpg" alt="img"></p>
<h3 id="3-3-预测阶段"><a href="#3-3-预测阶段" class="headerlink" title="3.3 预测阶段"></a><strong>3.3 预测阶段</strong></h3><p>同样，我们先把句子输入到我们的Encoder里面，Encoder会输入最后状态<img src="https://www.zhihu.com/equation?tex=%28h_0%2Cc_0%29" alt="[公式]">，作为这句话的特征送给Decoder。</p>
<p><img src="https://pic3.zhimg.com/80/v2-b04b4e5aa671501918c6490c2c061c6e_720w.jpg" alt="img"></p>
<p><img src="https://www.zhihu.com/equation?tex=%28h_0%2Cc_0%29" alt="[公式]">作为Decoder的初始状态，这样解码器就知道这句话是go away，首先把起始符输入，有了新的状态解码器就会把状态更新为<img src="https://www.zhihu.com/equation?tex=%28h_1%2Cc_1%29" alt="[公式]">并且预测下一个字符，decoder输出的是每个字符的概率值，我们可以根据这个概率值进行预测，比如我们可以选取概率值最大的字符，也可以对概率进行随机抽样，我可能会得到字符m，于是我把m记录下来。</p>
<p><img src="https://pic1.zhimg.com/80/v2-0885c1045a6203ce71e9d45f29ae569c_720w.jpg" alt="img"></p>
<p>现在状态是<img src="https://www.zhihu.com/equation?tex=%28h_1%2Cc_1%29" alt="[公式]">)，把新生成的字符m作为LSTM的输入，接下来再更新状态为<img src="https://www.zhihu.com/equation?tex=%28h_2%2Cc_2%29" alt="[公式]">,并且输出一个概率分布，根据概率分布抽样我们得到字符a，记录下字符a，并一直进行这个循环。</p>
<p><img src="https://pic3.zhimg.com/80/v2-ab0a601a28bd791980a7e2590a7b4b56_720w.jpg" alt="img"></p>
<p>运行14轮了状态是<img src="https://www.zhihu.com/equation?tex=%28h_%7B14%7D%2Cc_%7B14%7D%29" alt="[公式]">，再结合上一轮生成的字符e，根据decoder输出的概率分布抽样，我们抽到了终止符，一旦抽到了终止符，就终止文本生成，并返回记录下的字符串，德语也就被成功翻译了。</p>
<h3 id="3-4-总结"><a href="#3-4-总结" class="headerlink" title="3.4 总结"></a><strong>3.4 总结</strong></h3><p>Seq2Seq模型有一个encoder网络和一个Decoder网络，在我们的例子中encoder的输入是英语句子，每输入一个词RNN就会更新状态并记录下来，encoder最后一个状态就是这个句子的特征，并把之前的状态丢弃。把这个状态作为decoder的初始状态，初始化后decoder就知道这个句子了，首先把起始符作为decoder的输入，然后一步步更新，输出状态和概率分布预测下一个字符，再把预测的字符作为下一个输入，重复这个过程，最后直到预测终止符就返回输出的这个序列。</p>
<h3 id="3-5-如何提升？"><a href="#3-5-如何提升？" class="headerlink" title="3.5 如何提升？"></a><strong>3.5 如何提升？</strong></h3><p>我们的encoder和decoder都是LSTM，encoder把所有句子的特征压缩到最后一个状态，理想情况下encoder最后一个状态包含完整的信息，假如句子很长，那么句子有些信息就会被遗忘，那么Decoder就没有完整的句子信息，那decoder输出的德语句子就不完整。</p>
<p><img src="https://pic4.zhimg.com/80/v2-a937915c00b75b545bbb6cee598d4d9b_720w.jpg" alt="img"></p>
<p>一种简单方法就是使用双向LSTM，双向LSTM简单来说就是用两条链，从左到右这条链可能会遗忘最左边的信息，而从右往左的这条链可能会遗忘右边的信息，这样结合起来就不容易遗忘句子信息，这里要注意只是encoder用双向LSTM，decoder是单向LSTM，他要生成正确顺序的序列。</p>
<p><img src="https://pic1.zhimg.com/80/v2-fd186443cacf998d69a3d36052a17e18_720w.jpg" alt="img"></p>
<p>这次我们用的是char-level比较方便，但是最好还是使用word-level，因为用单词代替字母，序列就会短大概4.5倍，就不容易遗忘，但是用word-level需要大的数据集，得到的单词大概就是一万，one-hot之后向量的维度也就是一万，太大了，需要embedding进行降维，因为embedding参数很多，所以如果数据集不够很容易过拟合。</p>
<p><img src="https://pic3.zhimg.com/80/v2-cf15fa6bce6b4fd06c09a1d6443fe206_720w.jpg" alt="img"></p>
<p>另外一种方法改进就是multi-Task learning，我们还可以多加入几个任务，比如让英语句子让他自己翻译成英语句子，这样encoder只有一个但是数据多了一倍，这样encoder就能被训练的更好，当然你还可以添加其他语言的任务，通过借助其他语言更好训练encoder，这样虽然decoder没有变得更好，但是因为encoder提取的更好最后效果也会变好。</p>
<p>当然还有一个方法就是使用注意力机制，这个对机器翻译提高作用很大，我们接下来就讲解这个注意力机制。</p>
<h2 id="4-注意力机制"><a href="#4-注意力机制" class="headerlink" title="4 注意力机制"></a><strong>4 注意力机制</strong></h2><p>我们知道Seq2Seq模型有一个缺点就是句子太长的话encoder会遗忘，那么decoder接受到的句子特征也就不完全，我们看一下下面这个图，纵轴BLUE是机器翻译的指标，横轴是句子的单词量，我们可以看出用了attention之后模型的性能大大提升。</p>
<p><img src="https://pic4.zhimg.com/80/v2-dc82591391379249e0e5f2cd6c5dc64f_720w.jpg" alt="img"></p>
<p>用了注意力机制，Decoder每次更新状态的时候都会再看一遍encoder所有状态，还会告诉decoder要更关注哪部分，这也是attention名字的由来。但是缺点就是计算量很大。</p>
<p><img src="https://pic2.zhimg.com/80/v2-707b8da8452d377f6604ee2f1e6b67d9_720w.jpg" alt="img"></p>
<h3 id="4-1-attention原理"><a href="#4-1-attention原理" class="headerlink" title="4.1 attention原理"></a><strong>4.1 attention原理</strong></h3><p>在encoder结束之后，attention和decoder同时工作，回忆一下，decoder的初始状态<img src="https://www.zhihu.com/equation?tex=s_0" alt="[公式]">)是encoder最后一个状态，不同于常规的Seq2Seq，encoder所有状态都要保留，这里需要计算<img src="https://www.zhihu.com/equation?tex=s_0" alt="[公式]">)与每个状态的相关性，我使用<img src="https://www.zhihu.com/equation?tex=%5Calpha_i+%3D+aligh%28h_i%2Cs_0%29" alt="[公式]">)这个公式表示计算两者相关性，把结果即为<img src="https://www.zhihu.com/equation?tex=%5Calpha_i" alt="[公式]">)，记做Weight，encoder有m个状态，所以一共有m个<img src="https://www.zhihu.com/equation?tex=%5Calpha" alt="[公式]">，这里所有的值都是介于0和1的实数，全部加起来为1。</p>
<p><img src="https://pic3.zhimg.com/80/v2-f22774a0c56768176c88955405a0f642_720w.jpg" alt="img"></p>
<p>下面看一下怎么计算这个相似性。第一种方法是把<img src="https://www.zhihu.com/equation?tex=h_i" alt="[公式]">)和<img src="https://www.zhihu.com/equation?tex=S_o" alt="[公式]">)做concat得到更高的向量，然后求矩阵W与这个向量的乘积，得到一个向量，然后再将tanh作用于向量每一个元素，将他压到-1和1之间，最后计算向量V与刚才计算出来的向量的内积，这里的向量V和矩阵W都是参数，需要从训练数据里学习，算出m个<img src="https://www.zhihu.com/equation?tex=%5Calpha" alt="[公式]">)后，需要对他们做一个softmax变换，把输出结果记做<img src="https://www.zhihu.com/equation?tex=%5Calpha_1" alt="[公式]">)到<img src="https://www.zhihu.com/equation?tex=%5Calpha_m" alt="[公式]">，因为是softmax输出，所以他们都大于0相加为1，这是第一篇attention论文提出计算的方法，往后有很多其他计算的方法，我们来介绍一种更常用的方法。</p>
<p><img src="https://pic1.zhimg.com/80/v2-098bee41cda1fae3ec8d39e6a5726f98_720w.jpg" alt="img"></p>
<p>输入还是<img src="https://www.zhihu.com/equation?tex=h_i" alt="[公式]">)和<img src="https://www.zhihu.com/equation?tex=S_0" alt="[公式]">)，第一步是分别使用两个参数矩阵<img src="https://www.zhihu.com/equation?tex=W_k" alt="[公式]">)，<img src="https://www.zhihu.com/equation?tex=W_q" alt="[公式]">)做线性变换，得到<img src="https://www.zhihu.com/equation?tex=k_i" alt="[公式]">)和<img src="https://www.zhihu.com/equation?tex=q_0" alt="[公式]">)这两个向量，这两个参数矩阵要从训练数据中学习。第二步是计算<img src="https://www.zhihu.com/equation?tex=k_i" alt="[公式]">)与<img src="https://www.zhihu.com/equation?tex=q_0" alt="[公式]">)的内积，由于有m个K向量，所以得到L个<img src="https://www.zhihu.com/equation?tex=%5Calpha_i" alt="[公式]">)。第三步就是对这些值做一个softmax变换，<img src="https://www.zhihu.com/equation?tex=%5Calpha_1" alt="[公式]">)到<img src="https://www.zhihu.com/equation?tex=%5Calpha_m" alt="[公式]">，因为是softmax输出，所以他们都大于0相加为1。这种计算方法被Transformer模型采用，Transformer模型是当前很多nlp问题采用的先进模型。</p>
<p><img src="https://pic3.zhimg.com/80/v2-b1d288f2fee3d112e5553ba789ed16da_720w.jpg" alt="img"></p>
<p>刚才讲了两种方法来计算<img src="https://www.zhihu.com/equation?tex=h_i" alt="[公式]">)和<img src="https://www.zhihu.com/equation?tex=S_0" alt="[公式]">)的相关性，现在我们得到了m个相关性<img src="https://www.zhihu.com/equation?tex=%5Calpha" alt="[公式]">)，每个<img src="https://www.zhihu.com/equation?tex=%5Calpha" alt="[公式]">)对应每个状态<img src="https://www.zhihu.com/equation?tex=h_i" alt="[公式]">)，有了这些权重<img src="https://www.zhihu.com/equation?tex=%5Calpha" alt="[公式]">我们可以对m个状态计算加权平均，得到一个Context vector <img src="https://www.zhihu.com/equation?tex=C_0" alt="[公式]">。每一个Context vector都会对应一个decoder状态<img src="https://www.zhihu.com/equation?tex=s_i" alt="[公式]"></p>
<p><img src="https://pic2.zhimg.com/80/v2-845398014cd4b79e3a3b6cb0914c4e91_720w.jpg" alt="img"></p>
<p>接下来我们来看一下decoder是怎么计算新的状态的。我们来回顾一下，假如不用attention，我们是这样更新状态的，新的状态<img src="https://www.zhihu.com/equation?tex=S_1" alt="[公式]">)是旧状态<img src="https://www.zhihu.com/equation?tex=S_0" alt="[公式]">)与新输入<img src="https://www.zhihu.com/equation?tex=X_1%5E%60" alt="[公式]">`的函数，看一下下图左边的公式，将两者做concat，然后乘上权重矩阵加上偏置b，最后通过tanh就是我们的新状态，也就是说状态的更新仅仅是根据上一个状态，并不会看encoder的状态。用attention的话更新状态还要用到我们计算出的Context vector <img src="https://www.zhihu.com/equation?tex=C_0" alt="[公式]">，把三个参数一起做concat后更新。</p>
<p><img src="https://pic2.zhimg.com/80/v2-791c535e2ab9fb17415f735bf0ddadf1_720w.jpg" alt="img"></p>
<p>回忆一下，<img src="https://www.zhihu.com/equation?tex=C_0" alt="[公式]">)是所有encoder状态<img src="https://www.zhihu.com/equation?tex=h_i" alt="[公式]">)的加权平均，所以<img src="https://www.zhihu.com/equation?tex=C_0" alt="[公式]">)知道输入<img src="https://www.zhihu.com/equation?tex=X_1" alt="[公式]">)到<img src="https://www.zhihu.com/equation?tex=X_m" alt="[公式]">)的完整信息，decoder新的状态<img src="https://www.zhihu.com/equation?tex=S_1" alt="[公式]">)依赖于<img src="https://www.zhihu.com/equation?tex=C_0" alt="[公式]">，这样RNN遗忘的问题就解决了。下一步则是计算context vector <img src="https://www.zhihu.com/equation?tex=C_1" alt="[公式]">)，跟之前一样，先计算权重<img src="https://www.zhihu.com/equation?tex=%5Calpha_i" alt="[公式]">)，这里是计算<img src="https://www.zhihu.com/equation?tex=S_1" alt="[公式]">)跟之前encoder所有状态的相关性，得到了m个<img src="https://www.zhihu.com/equation?tex=%5Calpha" alt="[公式]">)，注意一下这里的权重也是要更新的，上一轮算的是跟<img src="https://www.zhihu.com/equation?tex=s_0" alt="[公式]">)的相关性现在算的是跟<img src="https://www.zhihu.com/equation?tex=S_1" alt="[公式]">)的相关性，这样就可以通过加权平均计算出新的<img src="https://www.zhihu.com/equation?tex=C_1" alt="[公式]">。</p>
<p><img src="https://pic3.zhimg.com/80/v2-7e7a882f89f155ebed2953fecaa9fa5e_720w.jpg" alt="img"></p>
<p>Decoder接受新的输入<img src="https://www.zhihu.com/equation?tex=X_2" alt="[公式]">，还是用那个公式计算出新状态，然后一直循环下去直到结束。</p>
<p><img src="https://pic4.zhimg.com/80/v2-c00b6408124f4f5f55969c161acba423_720w.jpg" alt="img"></p>
<p>我们知道在这个过程中我们会计算出很多权重<img src="https://www.zhihu.com/equation?tex=%5Calpha_i" alt="[公式]">)，我们思考一下我们究竟计算了多少个<img src="https://www.zhihu.com/equation?tex=%5Calpha" alt="[公式]">?想要计算出一个context vector<img src="https://www.zhihu.com/equation?tex=C_j" alt="[公式]">)，我们要计算出m个相似性权重<img src="https://www.zhihu.com/equation?tex=%5Calpha" alt="[公式]">，所以每轮更新都需要计算m个权重，假如一共有t个state，那么一共就要计算m×t个权重，也就是encoder和decoder数量的乘积。attention为了不遗忘，代价就是高数量级的计算。</p>
<p><img src="https://pic1.zhimg.com/80/v2-10014a64ff992b46b67f82ad9df8fdbc_720w.jpg" alt="img"></p>
<h3 id="4-2-权重的实际意义"><a href="#4-2-权重的实际意义" class="headerlink" title="4.2 权重的实际意义"></a><strong>4.2 权重<img src="https://www.zhihu.com/equation?tex=%5Calpha" alt="[公式]">的实际意义</strong></h3><p>这张图下面是encoder，上面是decoder，attention会把decoder所有状态与encoder所有状态计算相似性，也就是<img src="https://www.zhihu.com/equation?tex=%5Calpha" alt="[公式]">).在这张图中每条线就对应一个<img src="https://www.zhihu.com/equation?tex=%5Calpha" alt="[公式]">，线越粗说明相关性越高。</p>
<p><img src="https://pic3.zhimg.com/80/v2-9739f4ddbc3516519c6ce6dfa7bf319a_720w.jpg" alt="img"></p>
<p>比如下面，法语中的zone就是英语的Area，所以两者的线就很粗。</p>
<p><img src="https://pic2.zhimg.com/80/v2-2aa7a0aca4d473ff81a8ff6bb5f75659_720w.jpg" alt="img"></p>
<h3 id="4-3-总结"><a href="#4-3-总结" class="headerlink" title="4.3 总结"></a><strong>4.3 总结</strong></h3><p>这次仅仅是从机器翻译的角度介绍了attention的一个应用，attention在业界还是有很多应用的，比如self-attention,Transformer应用，希望以此为印子能够打开读者attention的大门。</p>
<h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5 参考"></a><strong>5 参考</strong></h2><p>1.colah’s blog<strong><a href="https://link.zhihu.com/?target=http%3A//colah.github.io/posts/2015-08-Understanding-LSTMs/">http://colah.github.io/posts/2015-08-Understanding-LSTMs/</a></strong></p>
<p>2.CS583 <strong><a href="https://link.zhihu.com/?target=https%3A//github.com/wangshusen/DeepLearning">https://github.com/wangshusen/DeepLearning</a></strong></p>
<h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/135970560">https://zhuanlan.zhihu.com/p/135970560</a></p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>欢迎大家关注鄙人的公众号【麦田里的守望者zhg】，让我们一起成长，谢谢。<br><img src="https://jums.club/images/wechataccount.jpg" alt="微信公众号"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">CrazyJums</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://jums.club/lstm-gru-rnn/">http://jums.club/lstm-gru-rnn/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/deep-learning/">deep learning</a></div><div class="post_share"><div class="social-share" data-image="https://jums.club/images/article/v2-6340abe431febf6304bafe9ca16edaba_1440w.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> Donate</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/wechatpay.jpg" target="_blank"><img class="post-qr-code-img" src="/images/wechatpay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/images/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/images/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li><li class="reward-item"><a href="/images/bitcoin.jpg" target="_blank"><img class="post-qr-code-img" src="/images/bitcoin.jpg" alt="bitcoin"/></a><div class="post-qr-code-desc">bitcoin</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/tcp-three-four/"><img class="prev-cover" src="https://jums.club/images/article/c8bca661280e4d40a2b64120461109f4.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">TCP/IP协议中的三次握手和四次挥手</div></div></a></div><div class="next-post pull-right"><a href="/cpp-virtual-function/"><img class="next-cover" src="https://jums.club/images/article/1_U-moh2EpPntprUBiugSuBQ.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">对c++中虚函数和纯虚函数的理解</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/AlexNet/" title="CNN典型模型：AlexNet"><img class="cover" src="https://jums.club/images/article/AlexNet.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-11-21</div><div class="title">CNN典型模型：AlexNet</div></div></a></div><div><a href="/SSPNet/" title="关于SSPNet（空间金字塔池化网络），了解一下"><img class="cover" src="https://jums.club/images/article/20150105213522578.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-11-21</div><div class="title">关于SSPNet（空间金字塔池化网络），了解一下</div></div></a></div><div><a href="/cnn/" title="关于卷积神经网络，了解一下"><img class="cover" src="https://jums.club/images/article/48540923dd54564e223d3494bdde9c82d0584fc7.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-11-21</div><div class="title">关于卷积神经网络，了解一下</div></div></a></div><div><a href="/dip/" title="数字图像处理（dip）"><img class="cover" src="https://jums.club/images/article/dip.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-11-16</div><div class="title">数字图像处理（dip）</div></div></a></div><div><a href="/gradient-descent/" title="关于深度学习中的梯度下降，了解一下"><img class="cover" src="https://jums.club/images/article/1234352-6ae594f795406b8b.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-11-21</div><div class="title">关于深度学习中的梯度下降，了解一下</div></div></a></div><div><a href="/lrn/" title="关于局部响应归一化层（LRN），了解一下"><img class="cover" src="https://jums.club/images/article/20170713162906129.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-11-21</div><div class="title">关于局部响应归一化层（LRN），了解一下</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">CrazyJums</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">230</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">63</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/crazyjums"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/crazyjums" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://jums.club/images/mywechat.jpg" target="_blank" title="Wechat"><i class="fa fa-comments"></i></a><a class="social-icon" href="https://blog.csdn.net/qq_33521184" target="_blank" title="Blog"><i class="fa fa-bold"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">如果有疑问可以微信我：crazyjumsz</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-number">1.</span> <span class="toc-text">目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-RNN%EF%BC%88%E9%80%92%E5%BD%92%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">1 RNN（递归神经网络）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-LSTM"><span class="toc-number">3.</span> <span class="toc-text">2 LSTM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E9%95%BF%E6%9C%9F%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.</span> <span class="toc-text">2.1 长期依赖问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-LSTM%E7%BD%91%E7%BB%9C"><span class="toc-number">3.2.</span> <span class="toc-text">2.2 LSTM网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-LSTM%E8%83%8C%E5%90%8E%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-number">3.3.</span> <span class="toc-text">2.3 LSTM背后的核心思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E4%B8%80%E6%AD%A5%E6%AD%A5%E6%8E%A8%E5%AF%BCLSTM"><span class="toc-number">3.4.</span> <span class="toc-text">2.4 一步步推导LSTM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-LSTM%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8F%98%E4%BD%93"><span class="toc-number">3.5.</span> <span class="toc-text">2.5 LSTM的一些变体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E7%BB%93%E8%AE%BA"><span class="toc-number">3.6.</span> <span class="toc-text">2.6 结论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Seq2Seq"><span class="toc-number">4.</span> <span class="toc-text">3 Seq2Seq</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%87%86%E5%A4%87%E6%95%B0%E6%8D%AE"><span class="toc-number">4.1.</span> <span class="toc-text">3.1 准备数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%90%AD%E5%BB%BA%E5%B9%B6%E8%AE%AD%E7%BB%83Seq2Seq%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.2.</span> <span class="toc-text">3.2 搭建并训练Seq2Seq模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E9%A2%84%E6%B5%8B%E9%98%B6%E6%AE%B5"><span class="toc-number">4.3.</span> <span class="toc-text">3.3 预测阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E6%80%BB%E7%BB%93"><span class="toc-number">4.4.</span> <span class="toc-text">3.4 总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%EF%BC%9F"><span class="toc-number">4.5.</span> <span class="toc-text">3.5 如何提升？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6"><span class="toc-number">5.</span> <span class="toc-text">4 注意力机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-attention%E5%8E%9F%E7%90%86"><span class="toc-number">5.1.</span> <span class="toc-text">4.1 attention原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%9D%83%E9%87%8D%E7%9A%84%E5%AE%9E%E9%99%85%E6%84%8F%E4%B9%89"><span class="toc-number">5.2.</span> <span class="toc-text">4.2 权重的实际意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E6%80%BB%E7%BB%93"><span class="toc-number">5.3.</span> <span class="toc-text">4.3 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%8F%82%E8%80%83"><span class="toc-number">6.</span> <span class="toc-text">5 参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E6%96%87"><span class="toc-number">7.</span> <span class="toc-text">原文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E"><span class="toc-number">8.</span> <span class="toc-text">写在最后</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/diff-v-bind-and-v-model/" title="vue中v-bind和v-model的区别？"><img src="https://jums.club/images/article2/v-bind_v-model.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="vue中v-bind和v-model的区别？"/></a><div class="content"><a class="title" href="/diff-v-bind-and-v-model/" title="vue中v-bind和v-model的区别？">vue中v-bind和v-model的区别？</a><time datetime="2022-01-17T03:07:23.000Z" title="Created 2022-01-17 11:07:23">2022-01-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/vue-import-at/" title="Vue中的import中@的作用"><img src="https://jums.club/images/article2/vue_import.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vue中的import中@的作用"/></a><div class="content"><a class="title" href="/vue-import-at/" title="Vue中的import中@的作用">Vue中的import中@的作用</a><time datetime="2022-01-17T03:02:08.000Z" title="Created 2022-01-17 11:02:08">2022-01-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/array-walk-and-array-map-diff/" title="PHP中array_walk和array_map的区别？"><img src="https://jums.club/images/article2/array_map_walk.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="PHP中array_walk和array_map的区别？"/></a><div class="content"><a class="title" href="/array-walk-and-array-map-diff/" title="PHP中array_walk和array_map的区别？">PHP中array_walk和array_map的区别？</a><time datetime="2022-01-06T12:39:23.000Z" title="Created 2022-01-06 20:39:23">2022-01-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/php-use-redis-scan-bug/" title="php使用redis的scan命令时遇到的坑"><img src="https://jums.club/images/article2/redis_scan.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="php使用redis的scan命令时遇到的坑"/></a><div class="content"><a class="title" href="/php-use-redis-scan-bug/" title="php使用redis的scan命令时遇到的坑">php使用redis的scan命令时遇到的坑</a><time datetime="2022-01-05T04:15:54.000Z" title="Created 2022-01-05 12:15:54">2022-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/php-dist-prod-and-test/" title="php区分线上环境和测试环境"><img src="https://jums.club/images/article2/v2-358b5d13d1655b793a9cc4853d9cb750_b.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="php区分线上环境和测试环境"/></a><div class="content"><a class="title" href="/php-dist-prod-and-test/" title="php区分线上环境和测试环境">php区分线上环境和测试环境</a><time datetime="2021-11-30T03:18:35.000Z" title="Created 2021-11-30 11:18:35">2021-11-30</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://jums.club/images/article/v2-6340abe431febf6304bafe9ca16edaba_1440w.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2022 By CrazyJums</div><div class="footer_custom_text">独立思考、不盲从、不撒谎</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      false && mermaid.init()
    })
  }
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '2lPeEraOnOk7GF6ou1WWs6BP-gzGzoHsz',
      appKey: 'nXeW1bmcRE4TDrorjmdqj0ML',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({{ JSON.stringify(config) }});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="{{ src }}">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end --></body></html>